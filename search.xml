<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ primer 学习笔记（七）]]></title>
    <url>%2F2017%2F07%2F15%2FC-primer-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[charpter 9 顺序容器本章内容为第三章的拓展内容。顺序容器类型提供了快速顺序访问元素的能力。 顺序容器概述 基本容器 vector/deque/list/forward_list/array/string vector，string 将元素保存在持续的内存空间。可以快速访问元素。但是在容器中间添加或删除元素会非常费时。 list和forward_list可以在任何位置添加或删除元素，但不支持随机访问，额外开销大 array 规定长度的数组 deque可以快速在头尾删除元素 反向容器 reverse_iterator c，c.rbegin(),c.rend()//逆序迭代 容器常用 迭代器范围 [begin,end) 拷贝指定范围内的元素 vector data(data2.begin(),data2.end()) array用法：array&lt;type,size&gt;与普通数组的差别：普通数组不支持拷贝，array支持拷贝，数组类型匹配即可。不支持{}赋值。 容器的拷贝与赋值： 赋值=。容器类型必须相同。赋值运算后，两容器大小相等，均为右侧容器大小，亦可通过{}赋值，除了array swap(c1,c2)交换元素。容器类型必须相同，速度较拷贝快 替换操作 c.assign(begin,end)//c.assign(il)//c.assign(n,t)//类型匹配即可（const* 与string亦可） 容器的大小操作：(1)容器的大小size();(2)容器的最大容纳元素数max_size()；（3）容器是否为空empty(); 顺序容器操作 push_front 在容器首添加元素（list,deque） insert 在容器任意部位插入元素(vector,deque,list,string)， 用法：（1）seq.insert(iterator,xx)插到迭代器位置之前。缺点耗时（2）seq.insert(iterator,n,xx)插10个（3）seq.insert(iteratot,{xx,xx,xx,xx}) insert返回值为指向当前位置的迭代器 访问元素 front/bach首尾元素 value = a.front();//必须保证非空 删除元素 （array不满足该操作） c.pop_back()、c.pop_front()（vector,string 不支持破pop_front和push_front）c.clear()c.erase(p)// 删除迭代器指定元素。返回删除后位置迭代器。c.erase(b,e)//删除迭代器b和e所制定范围内的元素。返回最后一个删除元素之后元素位置迭代器 、 改变容器大小（array不支持该操作）c.resize(size),若大小大于当前大小，则增加至容器尾部，若小于，则删除后部位容器元素。 *添加/删除vector、string、deque元素将导致迭代器失效。erase，insert操作可以更新迭代器，因为其返回值为更新后位置迭代器。 *不要保存end返回的迭代器。end = c.end() 不建议]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ primer 学习笔记（六）]]></title>
    <url>%2F2017%2F07%2F12%2FC-primer-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[charpter8 IO库IO类 基本io类：istream,ostream,cin(iosteam的一个对象),cout(ostream的一个对象) 基本io类2：iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型。 iosream: 从流中读写fstream：从文件中读写sstream：从string中读写 刷新输出缓冲区：endl-&gt;输出换行并刷新缓冲区 // flush-&gt;刷新 // ends-&gt; 输出空字符并刷新缓冲区 若每次输出操作后都刷新缓冲区，使用unitbuf，接下来的操作都进行一次flush操作。nounitbuf则回到正常的缓冲方式。 cout&lt;&lt;unitbuf //之后的输出均刷新cout&lt;&lt;nounitbuf //回到正常缓冲方式 文件的输入输出 头文件fstream支持文件IO：ifstream 从一个给定文件读取数据，ofstream向一个给定文件写入数据，以及fstream可以读写给定文件。 基本操作fstream my_file; //创建一个未绑定的文件流my_file.open(s); //打开名为s的文件：s可以为string或字符串的指针my_file.close()my_file.is_open() //bool值，指出与my_file关联的文件是否打开创建文件流方式：1）未绑定 2）绑定对象并打开fstream my_file(s) 3)绑定并以指定模式打开 fstream my_file(s,mode|mode) 打开模式mode ios::in 为输入(读)而打开文件 ios::out 为输出(写)而打开文件 ios::ate 初始位置：文件尾 ios::app 所有输出附加在文件末尾 ios::trunc 如果文件已存在则先删除该文件 ios::binary 二进制方式 ofstream 写文件 ifstream 读文件, 若写文件时文件不存在则新建 文件读写操作与cin，cout从控制台读写类似 举例： ofstream out(); 写文件out&lt;&lt;”…..”&lt;&gt;schar buff[255]; in.getline(buff,100); Tip: getline 用法（1）若是读进数组，则采用上述方式（2）若读入string data，则直接getline(in,data);写文件时，只有当模式为app时，才不会清除原文件。 string流的输入输出 sstream 的类型有istringstream、ostringstream、stringstream,分别为读、写、读写 sstream strm； //sstream strm(s) 保存string s 的一个拷贝 strm.str()；//返回strm中的值 strm.str(s)；// 将s拷贝到strm 注意 strm.str(s)只能赋值一次，若想再赋值，需要strm.clear(); 流的条件状态标志 假设s为某个流。如 iostream s // fstream s //sstream s s.eof() 若到达流末尾则返回trues.fail() 若流崩溃则返回true :读写过程中出问题，或写入设备无空间，或格式错误s.bad() 若流崩溃则返回true :读写过程中出问题，或写入设备无空间s.good() 流正常状态为true一般使用 s&gt;&gt;a为判断条件，其实使用的是s.good() http://blog.csdn.net/kingstar158/article/details/6859379]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ primer 学习笔记（五）]]></title>
    <url>%2F2017%2F07%2F02%2FC-primer-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[charpter7 类定义抽象数据类型 类中this一般指这个对象，类型为指向类 类型非常量 的常量指针，即 Struct_name *const // 常量指针，指向对象为非常量 如何转为指向常量的指针，在类成员函数参数列表之后添加const即可，该函数为常量成员函数，无法修改对象的内容。 常量对象，常量对象的引用或指针只能调用常量成员函数。 定义一个返回this对象的函数 函数的返回类型必须为 对象的引用 如 Sales_data &amp;，返回语句为return *this 构造函数 当需要默认构造函数时，一般写为 类名（）=default 构造函数初始值列表 类名（形参) ： 类成员（参数名），类成员（参数名）...）{}示例 ` Sales_data(const std::string &amp;s,unsigned n,double p) : bookNo(s),units_sold(n),revenue(p*n){ } 友元 类允许其他类或者函数访问它的非公有成员，方法是零其他类或者函数成为他的友元。在类中添加友元函数声明即可，friend 函数名 友元函数的声明与类本身放置在同一个头文件中类的其他特性 内联函数 ： 当函数在类内部定义时，默认为内联函数。在外部定义时需添加inline 友元类： 某个类访问其他类中的私有成员，必须声明为友元类。如A访问B，则在B中声明friend class A，友元关系不具有传递性 友元函数： 某个类的成员函数访问其他类中的私有成员，必须声明为友元函数。如类A中func1访问类B，则在B中声明friend A::func1. 友元声明的函数或类必须在使用之前显示声明再探构造函数 构造函数的初始值必不可少： 如果成员是const，或者引用必须通过构造函数初始值列表为成员提供处置。 默认构造函数 类名 对象名，注意，不需要括号。类的静态成员 关键词static ，静态数据成员的类型可以是常量，引用，指针。静态成员函数不能声明为const以及包含this指针 使用静态成员 类名::静态成员或者与普通一样使用]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ primer 学习笔记（四）]]></title>
    <url>%2F2017%2F06%2F28%2FC-primer-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[条件语句与函数基础charpter 5 case 标签必须是整型常量表达式 while 当不确定要迭代多少次时比较合适 continue 结束当次循环，continue后语句不执行 try – catch 异常处理 try{ 执行程序；抛出异常 } catch（异常）{处理异常} 抛出异常 throw 异常类型 表达式 throw runtime_error(“input must be int “) //这边抛出异常 类型为runtime_error 对象初始化为input must be int 常见异常 range_error 生成的结果超出值域范围invalid_argument 无效参数… charpter 6形参 函数返回类型不能是数组类型或者函数类型，可以是数组的指针或引用，或者是指向数组或函数的指针 局部静态对象 static 类型的变量 只初始化一次，直到main结束销毁，局部静态变量默认初始化为0； 传引用调用：形参是引用类型时，改变实参的值，实际是实参的别称。传值调用，形参和实参相互独立。 建议使用引用类型的形参来替代指针 注意： 使用引用 （当对象数据较大时，避免使用拷贝，例如string类型）如果函数无需改变引用形参的值，声明为const 引用使用引用形参，提供了一种返回多个对象的方法。使用引用形参时，尽量使用常量引用 数组形参 不允许拷贝数组以及使用数组时通常将其转换成指针。无法使用值传递，故而传递的是数组首元素的指针。即const int *,若需要改值，去掉const 由于传递的指针无法得知数组长度。一般使用(const int *a, size_t size) 数组引用形参 举例 int (&amp;arr)[10] 给这种形参赋值必须严格满足 多维数组形参 举例 int (*matrix)[10] &lt;==&gt; int matrix[][10] 表示指向含有10个整数的数组的指针 (int matrix[][10],int rowsize) //10列 rowsize行 main(int argc, char **argv) 其中argc表示参数个数，使用参数时从argv[1]开始，argv[0]保存程序名，故而argc至少为1 可变形参的函数 无法提前预知应该向函数传递几个实参 。若实参类型相同，可使用initializer_list标准库类型；类型不同，需编写可变参数模板。 initializer_list list //该类型对象元素均为常量值示例 int sum(initializer_list list) { int sum=0; for(auto beg=list.begin();beg !=list.end();++beg) sum += *beg; return sum; } sum({1,2,3}) ### 参数序列放在花括号内 返回类型及return语句 void函数可使用return语句，程序执行到return时退出。 不要返回局部对象的引用或指针 tip 函数 返回值和返回引用是不同的 函数返回值时会产生一个临时变量作为函数返回值的副本，而返回引用时不会产生值的副本。 返回引用函数return 不能返回临时变量或局部变量，返回参数可以 返回引用可以作为左值，即可赋值 string &amp;shortString(string &amp;data1,string &amp;data2) { return data1.size()&gt;data2.size()? data1:data2; } int main(int argc,char **argv) { string a=”boy”; string b=”girl”; shortString(a,b)=”hello”; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;endl; return 0; } 返回数组指针 ？ 形式为Type (*function(参数))[dimension] ,如 int(*func(int i))[10] //表示调用的数组大小为10函数重载 重载函数，形参数量和形参类型必须有所不同特殊用途语言特性 内联函数： 可避免函数调用的开销，适用于优化规模较小，流程直接，频繁调用的函数。用法 ： inline + 函数 调试帮助 assert 与NDEBUG assert(expt)//表达式为假输出信息，并终止程序，为真则不处理函数指针 函数指针指向的是函数而不是对象 bool (pf)(const string &amp;s1,const string &amp;s2) //pf指向一个函数，该函数参数是两个常字符串的引用，返回值为boolbool pf(const string &amp;s1,const string &amp;s2) //声明一个名为pf的函数，返回值为bool * 使用函数指针,直接将函数名赋给pf，例如 pf=lenthCompare 或者直接使用boo1 b1=pf(&quot;hello&quot;,&quot;compare&quot;); 函数指针形参 ，将函数指针作为形参， 例如 void useBigger(const string &amp;s1,const string &amp;s2,bool pf(const string &amp;,const string &amp;));使用时 useBigger(s1,s2,lenthCompare)使用typedef 以及 decltype 简化表达式。typedef bool (Func)(const string &amp;,const string &amp;)typedef decltype(lenthCompare) *Funcvoid useBigger(const string &amp;s1,const string &amp;s2,Func) 附录 double add(double x,double y) { return x+y; } double difference(double x,double y) { return x-y; } double calculator(double (Fun)(double, double), double x,double y) { return (Fun)(x,y); } int main(void) { double x=2; double y=4; double result1=calculator(add,x,y); double result2=calculator(difference,x,y);//调用者只需面对唯一的接口：calculator system(“pause”); return 0; }]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++primer 学习笔记（三）]]></title>
    <url>%2F2017%2F06%2F25%2FC-primer-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[charpter 4 逻辑与&amp;&amp; 只有左侧运算对象为真才会对右侧对象求值 逻辑或|| 只有左侧运算对象为假才会对右侧对象求值 ++i先加再执行，i++先执行再加 ，建议++i，运算等级最高 成员访问运算符 ptr-&gt;mem // (*ptr)-&gt;mem 条件运算符 cond ? expr1 : expre2 如果cond成立，expr1，否则expr2 位运算位运算作用于整数类型的对象 ， 运算符包括 ~ 位求反&lt;&lt; 左移 右移&amp; 位与^ 位异或| 异或 移位运算 左移&lt;&lt;在右侧插入值为0，右移若为无符号则在左插入0，否则插入符号位。 位异或 若只有1个1则为1 ，否则为0 置1 |= ，清0 &amp;=~sizeof运算符 返回一条表达式或一个类型名字所占的字节数，所得size_t类型，sizeof(type) sizeof expr 与strlen()比较strlen()计算字符数组的字符数，以”\0”为结束判断，不计算为’\0’的数组元素。而sizeof计算数据（包括数组、变量、类型、结构体等）所占内存空间，用字节数表示 指针与静态数组的sizeof操作，指针均可看为变量类型的一种。所有指针变量的sizeof 操作结果均为4 对于静态数组，sizeof可直接计算数组大小 注意：数组做型参时，数组名称当作指针使用！！ sizeof(s)等于string类的大小，sizeof(s.c_str())得到的是与字符串长度。 求数组元素的个数,通常有下面两种写法： int c1 = sizeof( a1 ) / sizeof( char ); // 总长度/单个元素的长度int c2 = sizeof( a1 ) / sizeof( a1[0] ); // 总长度/第一个元素的长度http://www.cnblogs.com/chengxin1982/archive/2009/01/13/1374575.html 类型转换 无符号+有符号运算 如果无符号类型不小于带符号的，那转为无符号的，如unsigned int 与 int 如无符号类型小于带符号的，结果依赖于机器]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS 导航学习 tf]]></title>
    <url>%2F2017%2F06%2F21%2FROS-%E5%AF%BC%E8%88%AA%E5%AD%A6%E4%B9%A0-tf%2F</url>
    <content type="text"><![CDATA[头文件 tf,geometry_msgs Broadcasting a Transform（广播变换）利用tf::TransformBroadcaster sendTransform进行坐标变换的广播 tf::StampedTransform::StampedTransform( const tf::Transform &amp; input, const ros::Time &amp; timestamp, const std::string &amp; frame_id, const std::string &amp; child_frame_id ) 广播内容 :第1个参数, 变换公式，Transform包括位姿pose和平移transform第2个参数，需要给转换关系携带一个时间戳，标记为ros::Time::now()；第3个参数，需要传递parent节点的名字； //想要变成的坐标系第4个参数，传递的是child节点的名字；由于tf假设所有的转换都是从parent到child的（考虑原点变换），当收到child坐标系的坐标，完成转化变成parent坐标系的坐标 Transform 的构造方式： tf::Transform::Transform(const Quaternion &amp; q, //四元素 const Vector3 &amp; c = Vector3(tfScalar(0), tfScalar(0), tfScalar(0)) ) tf::Transform::Transform(const Matrix3x3 &amp; b, //旋转矩阵 const Vector3 &amp; c = Vector3(tfScalar(0), tfScalar(0),tfScalar(0)) ) tf::Transform::Transform(const Transform &amp; othe//r)拷贝 #include &lt;ros/ros.h&gt; #include &lt;tf/transform_broadcaster.h&gt; int main(int argc, char** argv){ ros::init(argc, argv, &quot;robot_tf_publisher&quot;); ros::NodeHandle n; ros::Rate r(100); tf::TransformBroadcaster broadcaster; while(n.ok()){ broadcaster.sendTransform( tf::StampedTransform( tf::Transform(tf::Quaternion(0, 0, 0, 1), tf::Vector3(0.1, 0.0, 0.2)), ros::Time::now(),&quot;base_link&quot;, &quot;base_laser&quot;)); r.sleep(); } } Using a Transform（调用变换） tf::TransformListener 该对象会自动订阅ROS中的tf消息，并且管理所有的变换关系数据。 回调函数void transformPoint(const tf::TransformListener&amp; listener){ }PointStamped 类包含Point 以及Stamp (frame_id 和 时间戳) 利用 void TransformListener::transformPoint(const std::string &amp;target_frame, const geometry_msgs::PointStamped &amp; stamped_in, geometry_msgs::PointStamped &amp; stamped_out ) void Transformer::lookupTransform( const std::string &amp; target_frame, const std::string &amp; source_frame, const ros::Time &amp; time, StampedTransform &amp; transform ) //Get the transform between two frames by frame ID. #include &lt;ros/ros.h&gt; #include &lt;geometry_msgs/PointStamped.h&gt; #include &lt;tf/transform_listener.h&gt; void transformPoint(const tf::TransformListener&amp; listener){ geometry_msgs::PointStamped laser_point; laser_point.header.frame_id = &quot;base_laser&quot;; laser_point.header.stamp = ros::Time(); &lt;strong&gt;//just an arbitrary point in space&lt;/strong&gt; laser_point.point.x = 1.0; laser_point.point.y = 0.2; laser_point.point.z = 0.0; } int main(int argc, char** argv){ ros::init(argc, argv, &quot;robot_tf_listener&quot;); ros::NodeHandle n; tf::TransformListener listener(ros::Duration(10)); //we&apos;ll transform a point once every second ros::Timer timer = n.createTimer(ros::Duration(1.0), boost::bind(&amp;transformPoint, boost::ref(listener))); ros::spin(); }]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ primer学习笔记（二）]]></title>
    <url>%2F2017%2F06%2F20%2FC-primer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[charpter 3 using namespace::name例如 using std::cin ; //引入命名空间的某个成员 using namespace std ;//引入命名空间std string 标准库 #include string using namespace std; string 初始化 string s1(n,’c’) 将s1初始化为连续n个字符c组成 string a(“hello”) string 的基本操作 string s; 输入 cin&gt;&gt;s //忽略开头的空白 直到遇到下一处空白停止 读取一行 geline(cin, s) //保留空白 ，遇到换行符停止 empty 是否为空 size 返回长度不包含’/0’s.size() = strlen(s.c_str()) **注意size返回为无符号的整数 string 加法两侧必须有一个string 例如&quot;hello&quot;+&quot;dd&quot;不合法 string 字符的比较isalnum() isalpha() 头文件cctype或者ctype.h http://book.2cto.com/201309/32066.html 对string 对象每个字符操作 for（declaration ： expression） statement for（auto c : str） cout&lt;&lt;c&lt;&lt;endl; vector 标准库 头文件：include vectorvector&lt;T&gt; v1vector&lt;T&gt; v2(n,val) 列表初始化vector 对象vector&lt;T&gt; v3{&quot;d&quot;,&quot;b&quot;,&quot;c&quot;} 生成了三个对象**花括号表示列表初始化，圆括号表示构造对象 #####vector中添加元素push_back()在尾部添加元素 其他操作与string类型相似 ###注：size 操作得到的类型为size_typevector&lt;int&gt;::size_type lenthstring::size_type lenth 迭代器使用 迭代器运算符 == != 表示迭代器是否指向同一个元素，或者同一个迭代器是否只指向尾部 iter 返回对改元素的引用iter-&gt;mem == (*iter).mem++iter –iter如果为const_iterator 只能读，不能写例如string::const_iterator it vector&lt;int&gt;::const_iteratot itbegin()，end() 根据对象确定是否为常量cbegin(),cend() 返回为常值迭代器 vector 遍历方法 (1)for(auto a:s){...}(2)auto a = s.begin()//vector&lt;T&gt;::iterator a=s.begin() for(;a!=s.end();++a) {...} 数组 size_t 类型 用来表示数组下标 足够大足以存任意对象的大小 头文件cstddef // stddef.h unsigned intsize_t 类型表示C 中任何对象所能达到的最大长度。它是无符号整数， 因为负数在这里没有意义。它的目的是提供一种可移植的方法来声明与系统中可寻址的内存区域一致的长度。size_t 用做sizeof 操作符的返回值类型，同时也是很多函数的参数类型，包括malloc 和strlen。在声明诸如字符数或者数组索引这样的长度变量时用size_t 是好的做法。它经常用于循环计数器、数组索引，有时候还用在指针算术运算上。数组的遍历 也可使用for（auto i : scores）;数组begin 和 end ，int *beg = begin(ia); 注意：使用迭代器过程中不能使用push_back]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ primer学习笔记（二）]]></title>
    <url>%2F2017%2F06%2F20%2Ftest%2F</url>
    <content type="text"><![CDATA[charpter 3 using namespace::name例如 using std::cin ; //引入命名空间的某个成员 using namespace std ;//引入命名空间std string 标准库 #include using namespace std; string 初始化 string s1(n,’c’) 将s1初始化为连续n个字符c组成 string a(“hello”) string 的基本操作 string s 输入 cin&gt;&gt;s //忽略开头的空白 直到遇到下一处空白停止 读取一行 geline(cin, s) //保留空白 ，遇到换行符停止 empty 是否为空 size 返回长度不包含’/0’s.size() = strlen(s.c_str()) **注意size返回为无符号的整数 string 加法 两侧必须有一个string 例如&quot;hello&quot;+&quot;dd&quot;不合法 string 字符的比较 isalnum() isalpha()]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ primer 学习笔记（一）]]></title>
    <url>%2F2017%2F06%2F18%2FC-primer-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[charpter1 查看main函数的返回值： linux $ echo $ ?` windows $ echo %ERRORLEVEL% ` 标准输出输入对象：cout / cin / cerr / clog 显示警告和错误信息 endl：操纵符，结束当前行，并将与设备关联的缓冲区内容刷入设备中。 从键盘输入文件结束符 windows下 ctrl+Z ，unix下Ctrl+D 使用文件重定向 $ addItems \&lt;infile outfile\&gt;//addTtems为可执行文件charpter2 算术类型： char 8位short 16位int 16/32位long 32位long long 64位float 32位doubke 64位 类型转换： 给无符号类型赋值时，超出范围，则值为总数取模后的余数。例如unsigned char c= -1 ， c=-1%256=255 含有无符号类型的表达式 ： 无符号+有符号 ，会将有符号强行转成无符号，方式同上。若结果为负，也会转成无符号 全局变量和局部变量同名，可使用：：来使用全局变量的值 引用即别名，为已经存在的对象所起的另一个名字 int &amp;a=b；类型必须完全匹配，比如示例中b必须为int型 指针： 定义时 int p = &amp;a；类型必须相同，不能定义指向引用的指针。 空指针 ` int p=0；if（p）表示如果p不是空指针则` 常量指针int *const p，表示指针指向的地址无法改变，指针本身是常量 const int *p ,表示指针指向的对象是常量` 类型别名： typedef xx xx * using xx=xx 类型别名]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rviz]]></title>
    <url>%2F2017%2F05%2F19%2Frviz%2F</url>
    <content type="text"><![CDATA[学习Rviz 1.Markers: Sending Basic Shapes (C++)http://wiki.ros.org/rviz/Tutorials/Markers%3A%20Basic%20Shapes rviz中基本的类型有visualization_msgs/Marker Marker 类型中主要有 Header //包括框架和时间戳 ns //marker的名字 id //与ns一起创建唯一的 type //发送类型 action // 通常有ADD or DELETE geometry_msgs/Pose pose geometry_msgs/Vector3 scale std_msgs/ColorRGBA color duration lifetime //持续时间，ros::Duration()意味着不会自动删除 bool frame_locked 发布话题，消息类型为marker。rivz界面中添加marker，更改话题名。 -2.Markers: Points and Lines (C++) LINE_LIST 每一个线需要两个点 ，即一对点 markers不仅提供简单的形状类型，还有点、线段、线集合等。 LINE_STRIP 为点向量，每两点相连 -3.Markers: Interactive Markers rviz中基本的类型有 visualization_msgs/InteractiveMarker 如果你想创造一个节点提供一系列的交互markers，你需要构成一个InteractiveMarkerServer对象。rviz做为客户端。 ###交互marker需了解http://docs.ros.org/api/visualization_msgs/html/index-msg.htmlvisualization_msgs/InteractiveMarker, visualization_msgs/InteractiveMarkerControl and visualization_msgs/InteractiveMarkerFeedback Writing a Simple Interactive Marker Server 交互服务器编写 2.]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[marry you]]></title>
    <url>%2F2017%2F05%2F13%2Fmarry-you%2F</url>
    <content type="text"><![CDATA[BRUNO MARS - MARRY YOU|it’s a beautiful night we’re looking for something | dumb to do———- D Ehey| baby i think i wanna marry | you———- G Dis it the look in your eyes or is it | this dancing juice———- D Ewho | cares baby’ i think i wanna marry| you———- G D|well i know this little chapel on the boulevard———- Dwe can | go whoa whoa———- Eno one| will no whoa———- Goh |come on girl———- Dwho cares if we’re trashedgot a pocket full of cash we can blow whoa whoashots of patrol whoa whoaand guitar girldon’t say no no no no nojust say yeah yeah yeah yeah yeahand we’ll go go go go goif you’re ready’ like i’m readycos it’s a beautiful nigt we’re looking for something dumb to dohey baby i think i wanna marry youis it the look in your eyes or is it this dancing juicewho cares baby’ i think i wanna marry youohi’ll go get the ringlet the choir bell sing like ooh ooh oohso what you wanna do ooh oohlets just run girlif we wake up and you want to break upthat’s cool ooh oohno i won’t blame you ooh oohit was fun girldon’t say no no no no nojust say yeah yeah yeah yeah yeahand we’ll go go go go goif you’re ready’ like i’m readycos it’s a beautiful nigt we’re looking for something dumb to dohey baby i think i wanna marry youis it the look in your eyes or is it this dancing juicewho cares baby’ i think i wanna marry youjust say i do ooh ooh oohtell me right now babytell me right now baby’ babyjust say i do ooh ooh oohtell me right now babytell me right now baby’ babyohit’s a beautiful nigt we’re looking for something dumb to dohey baby i think i wanna marry youis it the look in your eyes or is it this dancing juicewho cares baby’ i think i wanna marry you]]></content>
      <tags>
        <tag>吉他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP编程]]></title>
    <url>%2F2017%2F05%2F11%2FUDP%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[UDP通信简单说来就是向固定IP发送数据，而不需要必须确认对方是否存在。通信过程简单，无需握手。当然也无法判断是否接收正常。 UDP编程过程：基本函数 建立套接字socket函数：为了执行网络输入输出，一个进程必须做的第一件事就是调用socket函数获得一个文件描述符。 sockfd=socket(AF_INET,SOCK_DGRAM,0)第一个参数指明了协议簇，目前支持5种协议簇，最常用的有AF_INET(IPv4协议)和AF_INET6(IPv6协议)；第二个参数指明套接口类型，有三种类型可选：SOCK_STREAM(字节流套接口)、SOCK_DGRAM(数据报套接口)和SOCK_RAW(原始套接口)；如果套接口类型不是原始套接口，那么第三个参数就为0。。 bind函数：为套接口分配一个本地IP和协议端口，对于网际协议，协议地址是32位IPv4地址或128位IPv6地址与16位的TCP或UDP端口号的组合；如指定端口为0，调用bind时内核将选择一个临时端口，如果指定一个通配IP地址，则要等到建立连接后内核才选择一个本地IP地址。int bind(int sockfd, const struct sockaddr * server, socklen_t addrlen); 第一个参数是socket函数返回的套接口描述字；第二和第第三个参数分别是一个指向特定于协议的地址结构的指针和该地址结构的长度。 recvfrom函数：UDP使用recvfrom()函数接收数据，他类似于标准的read()，但是在recvfrom()函数中要指明目的地址 ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr * from, size_t *addrlen);返回接收到数据的长度－－－成功 -1－－－失败 0—无数据 第一个参数套接字，第二个接受数组，第三个参数缓冲区长度，flags参数是传输控制标志，一般为0。from表示sockaddr结构地址，最后一个为sockaddr 结构大小 sendto函数：UDP使用sendto()函数发送数据，他类似于标准的write()，但是在sendto()函数中要指明目的地址。ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr * to, int addrlen);返回发送数据的长度－－－成功 -1－－－失败 前三个参数等同于函数read()的前三个参数，flags参数是传输控制标志。参数to指明数据将发往的协议地址，他的大小由addrlen参数来指定。 select函数：int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout); int maxfdp是一个整数值，指集合中所有文件描述符的范围，即所有文件描述符的最大值加1 fd_set *readfds是指向fd_set结构的指针，这个集合中应该包括读取文件描述符 fd_set *writefds是指向fd_set结构的指针，这个集合中应该写包括文件描述符 fd_set *errorfds同上面两个参数的意图，用来监视文件错误异常 struct timeval* timeout是select的超时时间，这个参数至关重要.超时时间内为阻塞，超时则调出，返回0值。错误返回-1； 服务端#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;unistd.h&gt; #include&lt;sys/types.h&gt; #include&lt;sys/socket.h&gt; #include&lt;stdlib.h&gt; #include&lt;netinet/in.h&gt; #include&lt;arpa/inet.h&gt; #define PORT 1234 #define MAXDATASIZE 100 main() { int sockfd; struct sockaddr_in server; socklen_t addrlen; int num; char buf[MAXDATASIZE]; if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) { perror(&quot;Creatingsocket failed.&quot;); exit(1); } bzero(&amp;server,sizeof(server)); server.sin_family=AF_INET; server.sin_port=htons(PORT); server.sin_addr.s_addr= htonl (INADDR_ANY); if(bind(sockfd, (struct sockaddr *)&amp;server, sizeof(server)) == -1) { perror(&quot;Bind()error.&quot;); exit(1); } addrlen=sizeof(server); while(1) { num =recvfrom(sockfd,buf,MAXDATASIZE,0,(struct sockaddr*)&amp;server,&amp;addrlen); if (num &lt; 0) { perror(&quot;recvfrom() error\n&quot;); exit(1); } buf[num] = &apos;\0&apos;; printf(&quot;You got a message (%s%) from client.\nIt&apos;s ip is%s, port is %d.\n&quot;,buf,inet_ntoa(client.sin_addr),htons(client.sin_port)); sendto(sockfd,&quot;Welcometo my server.\n&quot;,22,0,(struct sockaddr *)&amp;client,addrlen); close(sockfd); } 客户端#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;netdb.h&gt; #define UDP_TEST_PORT 8001 #define UDP_SERVER_IP &quot;192.168.60.169&quot; int main(int argc, char *argv[]) { struct sockaddr_in addr; int sockfd, len = 0; socklen_t addr_len = sizeof(struct sockaddr_in); char buffer[256]; /* 建立socket，注意必须是SOCK_DGRAM */ if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) { perror(&quot;socket&quot;); exit(1); } /* 填写sockaddr_in*/ bzero(&amp;addr, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(UDP_TEST_PORT); addr.sin_addr.s_addr = inet_addr(UDP_SERVER_IP); close(sockfd); buffer=&quot;hello&quot;; while(1) { sendto(sockfd, buffer, len, 0, (struct sockaddr *)&amp;addr, addr_len); sleep(2); /*睡眠2秒*/ printf(&quot;%s\n&quot;,buffer); } } Select由于recvfrom会造成程序堵塞，故而UDP一般可配合select函数使用 fd_set fds; timeval timeout={time,0}; int net; while（1) { timeout.tv_sec=time; timeout.tv_usec=0; FD_ZERO(&amp;fds); //描述符情空 FD_SET(sockfd,&amp;fds);//将套接字绑定描述符 net=0; net=select(sockfd+1,&amp;fds,NULL,NULL,&amp;timeout); if(net&lt;0) { exit(-1); } else if(net==0) { printf(&quot;timeout\n&quot;); } else { if(FD_ISSET(sockfd,&amp;fds)) { num =recvfrom(sockfd,buf,MAXDATASIZE,0,(struct sockaddr*); } } }]]></content>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人空间转换]]></title>
    <url>%2F2017%2F04%2F23%2F%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[rotation 前者表示坐标系A到B的旋转矩阵，后两个分别表示各坐标系下P点的坐标 3D transform Moving aroundThe camera observes point P in its own coordinate frame. But then the transform from the world to the camera is T. What’s the position of the point in the world coordinate? T*p reference frame changed point changedrelative movement Transform inverse]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown一些用法]]></title>
    <url>%2F2017%2F04%2F22%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[this is a test for markdown 插入公式方法： 1.利用latex在线生成公式代码http://latex.codecogs.com/eqneditor/editor.php 2.利用google chart服务器生成公式&lt;//img src=”http://chart.googleapis.com/chart?cht=tx&amp;chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}” style=”border:none;”//&gt;更改倾斜部分内容即可 ，双斜杠需删掉 更改字体：https://jingyan.baidu.com/article/380abd0a1c856d1d90192cd9.html http://blog.csdn.net/testcs_dn/article/details/45719357/ 我是黑体字 color=#0099ff size=72 face=”黑体”]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>