<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ primer学习笔记（二）]]></title>
    <url>%2F2017%2F06%2F20%2FC-primer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[charpter 3 using namespace::name例如 using std::cin ; //引入命名空间的某个成员 using namespace std ;//引入命名空间std string 标准库 #include string using namespace std; string 初始化 string s1(n,’c’) 将s1初始化为连续n个字符c组成 string a(“hello”) string 的基本操作 string s 输入 cin&gt;&gt;s //忽略开头的空白 直到遇到下一处空白停止 读取一行 geline(cin, s) //保留空白 ，遇到换行符停止 empty 是否为空 size 返回长度不包含’/0’s.size() = strlen(s.c_str()) **注意size返回为无符号的整数 string 加法两侧必须有一个string 例如&quot;hello&quot;+&quot;dd&quot;不合法 string 字符的比较isalnum() isalpha() 头文件cctype或者ctype.h http://book.2cto.com/201309/32066.html 对string 对象每个字符操作 for（declaration ： expression）statement for（auto c : str） cout&lt;&lt;c&lt;&lt;endl; vector 标准库 头文件：include vector&lt;T&gt; v1vector&lt;T&gt; v2(n,val) 列表初始化vector 对象vector&lt;T&gt; v3{&quot;d&quot;,&quot;b&quot;,&quot;c&quot;} 生成了三个对象**花括号表示列表初始化，圆括号表示构造对象 #####vector中添加元素push_back()在尾部添加元素 其他操作与string类型相似 ###注：size 操作的到的类型为size_typevector&lt;int&gt;::size_type lenthstring::size_type lenth]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ primer学习笔记（二）]]></title>
    <url>%2F2017%2F06%2F20%2Ftest%2F</url>
    <content type="text"><![CDATA[charpter 3 using namespace::name例如 using std::cin ; //引入命名空间的某个成员 using namespace std ;//引入命名空间std string 标准库 #include using namespace std; string 初始化 string s1(n,’c’) 将s1初始化为连续n个字符c组成 string a(“hello”) string 的基本操作 string s 输入 cin&gt;&gt;s //忽略开头的空白 直到遇到下一处空白停止 读取一行 geline(cin, s) //保留空白 ，遇到换行符停止 empty 是否为空 size 返回长度不包含’/0’s.size() = strlen(s.c_str()) **注意size返回为无符号的整数 string 加法 两侧必须有一个string 例如&quot;hello&quot;+&quot;dd&quot;不合法 string 字符的比较 isalnum() isalpha()]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ primer 学习笔记（一）]]></title>
    <url>%2F2017%2F06%2F18%2FC-primer-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[charpter1 查看main函数的返回值： linux $ echo $ ?` windows $ echo %ERRORLEVEL% ` 标准输出输入对象：cout / cin / cerr / clog 显示警告和错误信息 endl：操纵符，结束当前行，并将与设备关联的缓冲区内容刷入设备中。 从键盘输入文件结束符 windows下 ctrl+Z ，unix下Ctrl+D 使用文件重定向 $ addItems \&lt;infile outfile\&gt;//addTtems为可执行文件charpter2 算术类型： char 8位short 16位int 16/32位long 32位long long 64位float 32位doubke 64位 类型转换： 给无符号类型赋值时，超出范围，则值为总数取模后的余数。例如unsigned char c= -1 ， c=-1%256=255 含有无符号类型的表达式 ： 无符号+有符号 ，会将有符号强行转成无符号，方式同上。若结果为负，也会转成无符号 全局变量和局部变量同名，可使用：：来使用全局变量的值 引用即别名，为已经存在的对象所起的另一个名字 int &amp;a=b；类型必须完全匹配，比如示例中b必须为int型 指针： 定义时 int p = &amp;a；类型必须相同，不能定义指向引用的指针。 空指针 ` int p=0；if（p）表示如果p不是空指针则` 常量指针int *const p，表示指针指向的地址无法改变，指针本身是常量 const int *p ,表示指针指向的对象是常量` 类型别名： typedef xx xx * using xx=xx 类型别名]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rviz]]></title>
    <url>%2F2017%2F05%2F19%2Frviz%2F</url>
    <content type="text"><![CDATA[学习Rviz 1.Markers: Sending Basic Shapes (C++)http://wiki.ros.org/rviz/Tutorials/Markers%3A%20Basic%20Shapes rviz中基本的类型有visualization_msgs/Marker Marker 类型中主要有 Header //包括框架和时间戳 ns //marker的名字 id //与ns一起创建唯一的 type //发送类型 action // 通常有ADD or DELETE geometry_msgs/Pose pose geometry_msgs/Vector3 scale std_msgs/ColorRGBA color duration lifetime //持续时间，ros::Duration()意味着不会自动删除 bool frame_locked 发布话题，消息类型为marker。rivz界面中添加marker，更改话题名。 -2.Markers: Points and Lines (C++) LINE_LIST 每一个线需要两个点 ，即一对点 markers不仅提供简单的形状类型，还有点、线段、线集合等。 LINE_STRIP 为点向量，每两点相连 -3.Markers: Interactive Markers rviz中基本的类型有 visualization_msgs/InteractiveMarker 如果你想创造一个节点提供一系列的交互markers，你需要构成一个InteractiveMarkerServer对象。rviz做为客户端。 ###交互marker需了解http://docs.ros.org/api/visualization_msgs/html/index-msg.htmlvisualization_msgs/InteractiveMarker, visualization_msgs/InteractiveMarkerControl and visualization_msgs/InteractiveMarkerFeedback Writing a Simple Interactive Marker Server 交互服务器编写 2.]]></content>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[marry you]]></title>
    <url>%2F2017%2F05%2F13%2Fmarry-you%2F</url>
    <content type="text"><![CDATA[BRUNO MARS - MARRY YOU|it’s a beautiful night we’re looking for something | dumb to do———- D Ehey| baby i think i wanna marry | you———- G Dis it the look in your eyes or is it | this dancing juice———- D Ewho | cares baby’ i think i wanna marry| you———- G D|well i know this little chapel on the boulevard———- Dwe can | go whoa whoa———- Eno one| will no whoa———- Goh |come on girl———- Dwho cares if we’re trashedgot a pocket full of cash we can blow whoa whoashots of patrol whoa whoaand guitar girldon’t say no no no no nojust say yeah yeah yeah yeah yeahand we’ll go go go go goif you’re ready’ like i’m readycos it’s a beautiful nigt we’re looking for something dumb to dohey baby i think i wanna marry youis it the look in your eyes or is it this dancing juicewho cares baby’ i think i wanna marry youohi’ll go get the ringlet the choir bell sing like ooh ooh oohso what you wanna do ooh oohlets just run girlif we wake up and you want to break upthat’s cool ooh oohno i won’t blame you ooh oohit was fun girldon’t say no no no no nojust say yeah yeah yeah yeah yeahand we’ll go go go go goif you’re ready’ like i’m readycos it’s a beautiful nigt we’re looking for something dumb to dohey baby i think i wanna marry youis it the look in your eyes or is it this dancing juicewho cares baby’ i think i wanna marry youjust say i do ooh ooh oohtell me right now babytell me right now baby’ babyjust say i do ooh ooh oohtell me right now babytell me right now baby’ babyohit’s a beautiful nigt we’re looking for something dumb to dohey baby i think i wanna marry youis it the look in your eyes or is it this dancing juicewho cares baby’ i think i wanna marry you]]></content>
      <tags>
        <tag>吉他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP编程]]></title>
    <url>%2F2017%2F05%2F11%2FUDP%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[UDP通信简单说来就是向固定IP发送数据，而不需要必须确认对方是否存在。通信过程简单，无需握手。当然也无法判断是否接收正常。 UDP编程过程：基本函数 建立套接字socket函数：为了执行网络输入输出，一个进程必须做的第一件事就是调用socket函数获得一个文件描述符。 sockfd=socket(AF_INET,SOCK_DGRAM,0)第一个参数指明了协议簇，目前支持5种协议簇，最常用的有AF_INET(IPv4协议)和AF_INET6(IPv6协议)；第二个参数指明套接口类型，有三种类型可选：SOCK_STREAM(字节流套接口)、SOCK_DGRAM(数据报套接口)和SOCK_RAW(原始套接口)；如果套接口类型不是原始套接口，那么第三个参数就为0。。 bind函数：为套接口分配一个本地IP和协议端口，对于网际协议，协议地址是32位IPv4地址或128位IPv6地址与16位的TCP或UDP端口号的组合；如指定端口为0，调用bind时内核将选择一个临时端口，如果指定一个通配IP地址，则要等到建立连接后内核才选择一个本地IP地址。int bind(int sockfd, const struct sockaddr * server, socklen_t addrlen); 第一个参数是socket函数返回的套接口描述字；第二和第第三个参数分别是一个指向特定于协议的地址结构的指针和该地址结构的长度。 recvfrom函数：UDP使用recvfrom()函数接收数据，他类似于标准的read()，但是在recvfrom()函数中要指明目的地址 ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr * from, size_t *addrlen);返回接收到数据的长度－－－成功 -1－－－失败 0—无数据 第一个参数套接字，第二个接受数组，第三个参数缓冲区长度，flags参数是传输控制标志，一般为0。from表示sockaddr结构地址，最后一个为sockaddr 结构大小 sendto函数：UDP使用sendto()函数发送数据，他类似于标准的write()，但是在sendto()函数中要指明目的地址。ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr * to, int addrlen);返回发送数据的长度－－－成功 -1－－－失败 前三个参数等同于函数read()的前三个参数，flags参数是传输控制标志。参数to指明数据将发往的协议地址，他的大小由addrlen参数来指定。 select函数：int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout); int maxfdp是一个整数值，指集合中所有文件描述符的范围，即所有文件描述符的最大值加1 fd_set *readfds是指向fd_set结构的指针，这个集合中应该包括读取文件描述符 fd_set *writefds是指向fd_set结构的指针，这个集合中应该写包括文件描述符 fd_set *errorfds同上面两个参数的意图，用来监视文件错误异常 struct timeval* timeout是select的超时时间，这个参数至关重要.超时时间内为阻塞，超时则调出，返回0值。错误返回-1； 服务端#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;unistd.h&gt; #include&lt;sys/types.h&gt; #include&lt;sys/socket.h&gt; #include&lt;stdlib.h&gt; #include&lt;netinet/in.h&gt; #include&lt;arpa/inet.h&gt; #define PORT 1234 #define MAXDATASIZE 100 main() { int sockfd; struct sockaddr_in server; socklen_t addrlen; int num; char buf[MAXDATASIZE]; if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) { perror(&quot;Creatingsocket failed.&quot;); exit(1); } bzero(&amp;server,sizeof(server)); server.sin_family=AF_INET; server.sin_port=htons(PORT); server.sin_addr.s_addr= htonl (INADDR_ANY); if(bind(sockfd, (struct sockaddr *)&amp;server, sizeof(server)) == -1) { perror(&quot;Bind()error.&quot;); exit(1); } addrlen=sizeof(server); while(1) { num =recvfrom(sockfd,buf,MAXDATASIZE,0,(struct sockaddr*)&amp;server,&amp;addrlen); if (num &lt; 0) { perror(&quot;recvfrom() error\n&quot;); exit(1); } buf[num] = &apos;\0&apos;; printf(&quot;You got a message (%s%) from client.\nIt&apos;s ip is%s, port is %d.\n&quot;,buf,inet_ntoa(client.sin_addr),htons(client.sin_port)); sendto(sockfd,&quot;Welcometo my server.\n&quot;,22,0,(struct sockaddr *)&amp;client,addrlen); close(sockfd); } 客户端#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;netdb.h&gt; #define UDP_TEST_PORT 8001 #define UDP_SERVER_IP &quot;192.168.60.169&quot; int main(int argc, char *argv[]) { struct sockaddr_in addr; int sockfd, len = 0; socklen_t addr_len = sizeof(struct sockaddr_in); char buffer[256]; /* 建立socket，注意必须是SOCK_DGRAM */ if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) { perror(&quot;socket&quot;); exit(1); } /* 填写sockaddr_in*/ bzero(&amp;addr, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(UDP_TEST_PORT); addr.sin_addr.s_addr = inet_addr(UDP_SERVER_IP); close(sockfd); buffer=&quot;hello&quot;; while(1) { sendto(sockfd, buffer, len, 0, (struct sockaddr *)&amp;addr, addr_len); sleep(2); /*睡眠2秒*/ printf(&quot;%s\n&quot;,buffer); } } Select由于recvfrom会造成程序堵塞，故而UDP一般可配合select函数使用 fd_set fds; timeval timeout={time,0}; int net; while（1) { timeout.tv_sec=time; timeout.tv_usec=0; FD_ZERO(&amp;fds); //描述符情空 FD_SET(sockfd,&amp;fds);//将套接字绑定描述符 net=0; net=select(sockfd+1,&amp;fds,NULL,NULL,&amp;timeout); if(net&lt;0) { exit(-1); } else if(net==0) { printf(&quot;timeout\n&quot;); } else { if(FD_ISSET(sockfd,&amp;fds)) { num =recvfrom(sockfd,buf,MAXDATASIZE,0,(struct sockaddr*); } } }]]></content>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人空间转换]]></title>
    <url>%2F2017%2F04%2F23%2F%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[rotation 前者表示坐标系A到B的旋转矩阵，后两个分别表示各坐标系下P点的坐标 3D transform Moving aroundThe camera observes point P in its own coordinate frame. But then the transform from the world to the camera is T. What’s the position of the point in the world coordinate? T*p reference frame changed point changedrelative movement Transform inverse]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown一些用法]]></title>
    <url>%2F2017%2F04%2F22%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[this is a test for markdown 插入公式方法： 1.利用latex在线生成公式代码http://latex.codecogs.com/eqneditor/editor.php 2.利用google chart服务器生成公式&lt;//img src=”http://chart.googleapis.com/chart?cht=tx&amp;chl=\Large x=\frac{-b\pm\sqrt{b^2-4ac}}{2a}” style=”border:none;”//&gt;更改倾斜部分内容即可 ，双斜杠需删掉 更改字体：https://jingyan.baidu.com/article/380abd0a1c856d1d90192cd9.html http://blog.csdn.net/testcs_dn/article/details/45719357/ 我是黑体字 color=#0099ff size=72 face=”黑体”]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>